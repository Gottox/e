#include "common.h"
#include <rope.h>
#include <string.h>
#include <testlib.h>

static void
cursor_basic(void) {
	int rv = 0;
	struct Rope r = {0};
	rv = rope_init(&r);
	ASSERT_EQ(0, rv);

	rv = rope_append_str(&r, "This is a string");
	ASSERT_EQ(0, rv);

	struct RopeCursor c = {0};
	rv = rope_cursor_init(&c, &r);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_move_to(&c, 0, 9);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_insert_str(&c, "n awesome", 0);
	ASSERT_EQ(0, rv);

	struct RopeNode *node = rope_first(&r);
	ASSERT_TRUE(NULL != node);
	size_t size = 0;
	const uint8_t *value = rope_node_value(node, &size);
	ASSERT_TRUE(NULL != value);
	ASSERT_EQ((size_t)9, size);
	ASSERT_STREQS("This is a", (const char *)value, size);

	node = rope_node_next(node);
	ASSERT_TRUE(NULL != node);
	value = rope_node_value(node, &size);
	ASSERT_TRUE(NULL != value);
	ASSERT_EQ((size_t)9, size);
	ASSERT_EQ(0, memcmp(value, "n awesome", size));

	node = rope_node_next(node);
	ASSERT_NOT_NULL(node);
	value = rope_node_value(node, &size);
	ASSERT_NOT_NULL(value);
	ASSERT_EQ((size_t)7, size);
	ASSERT_EQ(0, memcmp(value, " string", size));

	rv = rope_cursor_cleanup(&c);
	ASSERT_EQ(0, rv);
	rv = rope_cleanup(&r);
	ASSERT_EQ(0, rv);
}

static void
cursor_utf8(void) {
	int rv = 0;
	struct Rope r = {0};
	rv = rope_init(&r);
	ASSERT_EQ(0, rv);

	rv = rope_append_str(&r, u8"ðŸ‘‹ðŸ¦¶");
	ASSERT_EQ(0, rv);

	struct RopeCursor c = {0};
	rv = rope_cursor_init(&c, &r);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_move_to(&c, 0, 1);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_insert_str(&c, u8"ðŸ™‚", 0);
	ASSERT_EQ(0, rv);

	struct RopeNode *node = rope_first(&r);
	ASSERT_TRUE(NULL != node);
	size_t size = 0;
	const uint8_t *value = rope_node_value(node, &size);
	ASSERT_TRUE(NULL != value);
	ASSERT_EQ((size_t)8, size);
	ASSERT_EQ(0, memcmp(value, u8"ðŸ‘‹ðŸ™‚", size));

	// struct RopeNode *node = rope_first(&r);
	// ASSERT_TRUE(NULL != node);
	// size_t size = 0;
	// const uint8_t *value = rope_node_value(node, &size);
	// ASSERT_TRUE(NULL != value);
	// ASSERT_EQ((size_t)4, size);
	// ASSERT_EQ(0, memcmp(value, u8"ðŸ‘‹", size));

	// bool has_next = rope_node_next(&node);
	// ASSERT_EQ(true, has_next);
	// ASSERT_TRUE(NULL != node);
	// value = rope_node_value(node, &size);
	// ASSERT_TRUE(NULL != value);
	// ASSERT_EQ((size_t)4, size);
	// ASSERT_EQ(0, memcmp(value, u8"ðŸ™‚", size));

	node = rope_node_next(node);
	ASSERT_TRUE(NULL != node);
	value = rope_node_value(node, &size);
	ASSERT_TRUE(NULL != value);
	ASSERT_EQ((size_t)4, size);
	ASSERT_EQ(0, memcmp(value, u8"ðŸ¦¶", size));

	rv = rope_cursor_cleanup(&c);
	ASSERT_EQ(0, rv);
	rv = rope_cleanup(&r);
	ASSERT_EQ(0, rv);
}

static void
cursor_event(void) {
	int rv = 0;
	struct Rope r = {0};
	rv = rope_init(&r);
	ASSERT_EQ(0, rv);

	rv = rope_append_str(&r, u8"This is a test");
	ASSERT_EQ(0, rv);

	struct RopeCursor c1 = {0};
	rv = rope_cursor_init(&c1, &r);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_move_to(&c1, 0, 10);
	ASSERT_EQ(0, rv);

	struct RopeCursor c2 = {0};
	rv = rope_cursor_init(&c2, &r);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_move_to(&c2, 0, 0);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_delete(&c2, 7);
	ASSERT_EQ(0, rv);

	ASSERT_EQ((size_t)3, c1.index);

	rv = rope_cursor_cleanup(&c1);
	ASSERT_EQ(0, rv);
	rv = rope_cursor_cleanup(&c2);
	ASSERT_EQ(0, rv);
	rv = rope_cleanup(&r);
	ASSERT_EQ(0, rv);
}

static void
cursor_move_codepoint(void) {
	int rv = 0;
	struct Rope r = {0};
	rv = rope_init(&r);
	ASSERT_EQ(0, rv);

	rv = rope_append_str(&r, "AðŸ˜ƒC");
	ASSERT_EQ(0, rv);

	struct RopeCursor c = {0};
	rv = rope_cursor_init(&c, &r);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_move_to_index(&c, 1, 0);
	ASSERT_EQ(0, rv);
	int32_t cp = rope_cursor_codepoint(&c);
	ASSERT_EQ(128515, cp);

	rv = rope_cursor_move(&c, -2);
	ASSERT_EQ(0, rv);
	ASSERT_EQ((size_t)0, c.index);

	rv = rope_cursor_cleanup(&c);
	ASSERT_EQ(0, rv);
	rv = rope_cleanup(&r);
	ASSERT_EQ(0, rv);
}

static void
cursor_insert_cursor_move(void) {
	int rv = 0;
	struct Rope r = {0};
	rv = rope_init(&r);
	ASSERT_EQ(0, rv);

	rv = rope_append_str(&r, "Hello World");
	ASSERT_EQ(0, rv);

	struct RopeCursor c1 = {0};
	rv = rope_cursor_init(&c1, &r);
	ASSERT_EQ(0, rv);

	struct RopeCursor c2 = {0};
	rv = rope_cursor_init(&c2, &r);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_insert_str(&c1, "c1", 0);

	ASSERT_EQ(0, c2.index);
	ASSERT_EQ(2, c1.index);

	rv = rope_cursor_cleanup(&c1);
	ASSERT_EQ(0, rv);
	rv = rope_cursor_cleanup(&c2);
	ASSERT_EQ(0, rv);
	rv = rope_cleanup(&r);
	ASSERT_EQ(0, rv);
}

static void
cursor_delete_collapses_following(void) {
	int rv = 0;
	struct Rope r = {0};
	rv = rope_init(&r);
	ASSERT_EQ(0, rv);

	rv = rope_append_str(&r, "Hello");
	ASSERT_EQ(0, rv);

	struct RopeCursor start = {0};
	rv = rope_cursor_init(&start, &r);
	ASSERT_EQ(0, rv);
	struct RopeCursor follower = {0};
	rv = rope_cursor_init(&follower, &r);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_move_to_index(&follower, rope_char_size(&r), 0);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_delete(&start, 5);
	ASSERT_EQ(0, rv);

	ASSERT_EQ((size_t)0, follower.index);
	ASSERT_EQ(0, rope_char_size(&r));

	rv = rope_cursor_cleanup(&start);
	ASSERT_EQ(0, rv);
	rv = rope_cursor_cleanup(&follower);
	ASSERT_EQ(0, rv);
	rv = rope_cleanup(&r);
	ASSERT_EQ(0, rv);
}

static void
cursor_delete_updates_tagged_cursors(void) {
	const uint64_t TAG_RED = 1u << 0;
	const uint64_t TAG_BLUE = 1u << 1;
	int rv = 0;
	struct Rope r = {0};
	rv = rope_init(&r);
	ASSERT_EQ(0, rv);

	struct RopeCursor editor = {0};
	rv = rope_cursor_init(&editor, &r);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_insert_str(&editor, "red", TAG_RED);
	ASSERT_EQ(0, rv);
	rv = rope_cursor_move_to_index(&editor, rope_char_size(&r), 0);
	ASSERT_EQ(0, rv);
	rv = rope_cursor_insert_str(&editor, "blue", TAG_BLUE);
	ASSERT_EQ(0, rv);

	struct RopeCursor tagged = {0};
	rv = rope_cursor_init(&tagged, &r);
	ASSERT_EQ(0, rv);
	rv = rope_cursor_move_to_index(&tagged, 0, TAG_BLUE);
	ASSERT_EQ(0, rv);
	ASSERT_EQ((size_t)3, tagged.index);

	rv = rope_cursor_move_to_index(&editor, 0, 0);
	ASSERT_EQ(0, rv);
	rv = rope_cursor_delete(&editor, 3);
	ASSERT_EQ(0, rv);

	ASSERT_EQ((size_t)0, tagged.index);
	ASSERT_EQ(4, rope_char_size(&r));

	struct RopeNode *node = rope_first(&r);
	ASSERT_TRUE(NULL != node);
	size_t size = 0;
	const uint8_t *value = rope_node_value(node, &size);
	ASSERT_STREQS("blue", (const char *)value, size);

	rv = rope_cursor_cleanup(&tagged);
	ASSERT_EQ(0, rv);
	rv = rope_cursor_cleanup(&editor);
	ASSERT_EQ(0, rv);
	rv = rope_cleanup(&r);
	ASSERT_EQ(0, rv);
}

static void
cursor_delete_at_eof(void) {
	struct Rope r = {0};
	struct RopeCursor c = {0};
	int rv = 0;

	rv = rope_init(&r);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_init(&c, &r);
	ASSERT_EQ(0, rv);

	const char *hello_world = "Hello World";
	for (size_t i = 0; i < strlen(hello_world); i++) {
		rv = rope_cursor_insert(&c, (const uint8_t *)&hello_world[i], 1, i);
		ASSERT_EQ(0, rv);
		// rope_node_print(r.root, "/tmp/node.dot");
	}
	rv = rope_cursor_move_to_index(&c, 10, 0);
	ASSERT_EQ(0, rv);
	rv = rope_cursor_delete(&c, 1);
	ASSERT_EQ(0, rv);

	char *result = rope_to_str(&r, 0);
	ASSERT_STREQ(result, "Hello Worl");
	free(result);

	rope_cursor_cleanup(&c);
	rope_cleanup(&r);
}

static void
cursor_delete_edit_traces_error1(void) {
	const char before_good[] = {
			0x23, 0x20, 0x4a, 0x53, 0x4f, 0x4e, 0x20, 0x43, 0x52, 0x44, 0x54,
			0x20, 0x50, 0x61, 0x74, 0x63, 0x68, 0x0a, 0x0a, 0x50, 0x61, 0x74,
			0x63, 0x68, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
			0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74,
			0x69, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x4a, 0x53, 0x4f,
			0x4e, 0x20, 0x43, 0x52, 0x44, 0x54, 0x2e, 0x0a, 0x0a, 0x0a, 0x23,
			0x23, 0x20, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x61,
			0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x0a, 0x23, 0x23, 0x23, 0x20, 0x4a,
			0x53, 0x4f, 0x4e, 0x20, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e,
			0x67, 0x0a, 0x0a, 0x23, 0x23, 0x23, 0x20, 0x43, 0x72, 0x65, 0x61,
			0x74, 0x65, 0x20, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
			0x6e, 0x0a, 0x0a, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x63,
			0x72, 0x65, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x65, 0x78, 0x61,
			0x6d, 0x70, 0x6c, 0x65, 0x3a, 0x0a, 0x0a, 0x60, 0x60, 0x60, 0x6a,
			0x73, 0x6f, 0x6e, 0x0a, 0x7b, 0x0a, 0x20, 0x20, 0x22, 0x6f, 0x70,
			0x22, 0x3a, 0x20, 0x22, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x22,
			0x2c, 0x0a, 0x20, 0x20, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a,
			0x20, 0x22, 0x73, 0x74, 0x72, 0x22, 0x2c, 0x0a, 0x7d, 0x0a, 0x60,
			0x60, 0x60, 0x0a, 0x0a, 0x54, 0x79, 0x70, 0x65, 0x20, 0x64, 0x65,
			0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x0a, 0x0a,
			0x60, 0x60, 0x60, 0x74, 0x79, 0x70, 0x65, 0x73, 0x63, 0x72, 0x69,
			0x70, 0x74, 0x0a, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63,
			0x65, 0x20, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4f, 0x70, 0x65,
			0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x7b, 0x0a, 0x20, 0x20,
			0x6f, 0x70, 0x3a, 0x20, 0x22, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
			0x22, 0x3b, 0x0a, 0x20, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3a, 0x20,
			0x22, 0x76, 0x61, 0x6c, 0x22, 0x20, 0x7c, 0x20, 0x22, 0x6f, 0x62,
			0x6a, 0x22, 0x20, 0x7c, 0x20, 0x22, 0x73, 0x74, 0x72, 0x22, 0x20,
			0x7c, 0x20, 0x22, 0x61, 0x72, 0x72, 0x22, 0x20, 0x7c, 0x20, 0x22,
			0x74, 0x75, 0x70, 0x22, 0x20, 0x7c, 0x20, 0x22, 0x63, 0x6f, 0x6e,
			0x73, 0x74, 0x22, 0x20, 0x7c, 0x20, 0x22, 0x62, 0x69, 0x6e, 0x22,
			0x3b, 0x0a, 0x7d, 0x0a, 0x60, 0x60, 0x60, 0x0a, 0,
	};
	const char after_good[] = {
			0x23, 0x20, 0x4a, 0x53, 0x4f, 0x4e, 0x20, 0x43, 0x52, 0x44, 0x54,
			0x20, 0x50, 0x61, 0x74, 0x63, 0x68, 0x0a, 0x0a, 0x50, 0x61, 0x74,
			0x63, 0x68, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
			0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74,
			0x69, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x4a, 0x53, 0x4f,
			0x4e, 0x20, 0x43, 0x52, 0x44, 0x54, 0x2e, 0x0a, 0x0a, 0x0a, 0x23,
			0x23, 0x20, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x61,
			0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x0a, 0x23, 0x23, 0x23, 0x20, 0x4a,
			0x53, 0x4f, 0x4e, 0x20, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e,
			0x67, 0x0a, 0x0a, 0x23, 0x23, 0x23, 0x20, 0x43, 0x72, 0x65, 0x61,
			0x74, 0x65, 0x20, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
			0x6e, 0x0a, 0x0a, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x63,
			0x72, 0x65, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x65, 0x78, 0x61,
			0x6d, 0x70, 0x6c, 0x65, 0x3a, 0x0a, 0x0a, 0x60, 0x60, 0x60, 0x6a,
			0x73, 0x6f, 0x6e, 0x0a, 0x7b, 0x0a, 0x20, 0x20, 0x22, 0x6f, 0x70,
			0x22, 0x3a, 0x20, 0x22, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x22,
			0x2c, 0x0a, 0x20, 0x20, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a,
			0x20, 0x22, 0x73, 0x74, 0x72, 0x22, 0x2c, 0x0a, 0x7d, 0x0a, 0x60,
			0x60, 0x60, 0x0a, 0x0a, 0x54, 0x79, 0x70, 0x65, 0x20, 0x64, 0x65,
			0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x0a, 0x0a,
			0x60, 0x60, 0x60, 0x74, 0x79, 0x70, 0x65, 0x73, 0x63, 0x72, 0x69,
			0x70, 0x74, 0x0a, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63,
			0x65, 0x20, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4f, 0x70, 0x65,
			0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x7b, 0x0a, 0x20, 0x20,
			0x6f, 0x70, 0x3a, 0x20, 0x22, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
			0x22, 0x3b, 0x0a, 0x20, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3a, 0x20,
			0x22, 0x76, 0x61, 0x6c, 0x22, 0x20, 0x7c, 0x20, 0x22, 0x6f, 0x62,
			0x6a, 0x22, 0x20, 0x7c, 0x20, 0x22, 0x73, 0x74, 0x72, 0x22, 0x20,
			0x7c, 0x20, 0x22, 0x61, 0x72, 0x72, 0x22, 0x20, 0x7c, 0x20, 0x22,
			0x74, 0x75, 0x70, 0x22, 0x20, 0x7c, 0x20, 0x22, 0x62, 0x69, 0x6e,
			0x22, 0x3b, 0x0a, 0x7d, 0x0a, 0x60, 0x60, 0x60, 0x0a, 0,
	};
	struct Rope r = {0};
	struct RopeCursor c = {0};
	int rv = 0;

	rv = rope_init(&r);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_init(&c, &r);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_insert_str(&c, before_good, 0);
	ASSERT_EQ(0, rv);
	rv = rope_cursor_move_to_index(&c, 326, 0);
	ASSERT_EQ(0, rv);
	rv = rope_cursor_delete(&c, 10);
	ASSERT_EQ(0, rv);

	char *result = rope_to_str(&r, 0);
	ASSERT_STREQ(after_good, result);
	free(result);

	rope_cursor_cleanup(&c);
	rope_cleanup(&r);
}

static void
test_cursor_delete_multi_node(void) {
	struct Rope r = {0};
	struct RopeCursor c = {0};
	int rv = 0;

	rv = rope_init(&r);
	ASSERT_EQ(0, rv);

	rope_node_free(r.root, &r.pool);

	r.root = from_str(
			&r.pool, "[[['HE','L'],['L','O']],[['W','O'],['R','LD']]]");

	rv = rope_cursor_init(&c, &r);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_move_to_index(&c, 1, 0);
	ASSERT_EQ(0, rv);

	rv = rope_cursor_delete(&c, 8);

	ASSERT_JSONEQ("['H','D']", r.root);

	rope_cursor_cleanup(&c);
	rope_cleanup(&r);
}

static void
test_cursor_delete_root_noninline_leaf(void) {
	int rv = 0;
	struct Rope rope = {0};
	struct RopeRange range = {0};

	rv = rope_init(&rope);
	ASSERT_EQ(0, rv);
	rv = rope_range_init(&range, &rope);
	ASSERT_EQ(0, rv);

	rv = rope_range_insert_str(
			&range,
			"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
			"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
			0x0);
	ASSERT_EQ(0, rv);
	rv = rope_range_delete(&range);
	ASSERT_EQ(0, rv);
	rope_range_cleanup(&range);
	rope_cleanup(&rope);
}

DECLARE_TESTS
TEST(cursor_basic)
TEST(cursor_utf8)
TEST(cursor_event)
TEST(cursor_move_codepoint)
TEST(cursor_insert_cursor_move)
TEST(cursor_delete_collapses_following)
TEST(cursor_delete_updates_tagged_cursors)
TEST(cursor_delete_at_eof)
TEST(cursor_delete_edit_traces_error1)
TEST(test_cursor_delete_multi_node)
TEST(test_cursor_delete_root_noninline_leaf)
END_TESTS
